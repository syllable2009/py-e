_executor = ThreadPoolExecutor(max_workers=10)
_executor.shutdown(wait=True)
# ThreadPoolExecutor 的优势
✅ 自动管理线程生命周期
✅ 限制最大并发数（避免资源耗尽）
✅ 提供简洁的异步任务提交接口
✅ 支持批量任务处理和结果收集

# 创建线程池（推荐使用 with 语句）
def fetch_url(url):
    response = requests.get(url)
    return len(response.content)

urls = [
    "https://httpbin.org/delay/1",
    "https://httpbin.org/delay/1",
    "https://httpbin.org/delay/1"
]

with ThreadPoolExecutor(max_workers=3) as executor:
    results = executor.map(fetch_url, urls)  # 返回迭代器,map() 会保持输入顺序，即使任务完成顺序不同
    for size in results:
        print(f"页面大小: {size}")



with ThreadPoolExecutor() as executor:
    futures = [executor.submit(fetch_url, i) for i in range(5)]
    for i, future in enumerate(futures):
        try:
            result = future.result(timeout=3)  # 3秒超时
            print(f"任务 {i}: {result}")
        except TimeoutError:
            print(f"任务 {i}: 超时")
        except Exception as e:
            print(f"任务 {i}: 出错 - {e}")


if __name__ == "__main__":
    image_urls = {
        "img1.jpg": "https://example.com/1.jpg",
        "img2.jpg": "https://example.com/2.jpg",
        # ... 更多
    }
    
    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = {
            executor.submit(download_image, url, name): name
            for name, url in image_urls.items()
        }
        
        for future in as_completed(futures):
            print(future.result())