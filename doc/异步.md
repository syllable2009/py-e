# 在 Python 中，async 和 await 是 异步编程（Asynchronous Programming） 的核心关键字，用于编写非阻塞、高并发的代码（如网络请求、文件 I/O、数据库查询等）。
async/await 不是魔法——它只是让 I/O 等待期间切换去干别的事，从而提升并发效率。
对于 CPU 密集型任务，它不会加速 。

概念	                       说明
协程（Coroutine）	一种可以暂停和恢复执行的函数，由 async def 定义
事件循环（Event Loop）	调度协程执行的“引擎”，负责管理异步任务
异步任务（Task）	被事件循环调度的协程包装对象
await	暂停当前协程，等待另一个协程/可等待对象完成
Future	表示一个最终会完成的操作（Task 是 Future 的子类）
awaitable	可被 await 的对象（协程、Task、Future）

# 思想
当一个协程遇到 I/O 操作（如网络请求）时，不阻塞整个程序，而是让出控制权给事件循环，去执行其他任务，等 I/O 完成后再恢复。
async def greet(name):
    print(f"Hello, {name}!")
    return f"Hi {name}"
调用 greet("Alice") 不会立即执行，而是返回一个 协程对象（coroutine object）

# 常见问题
# 误区 1：在普通函数中使用 await
def bad_example():
    await asyncio.sleep(1)  # SyntaxError! 使用 await 必须在 async def 中

# 误区 2：忘记 await 协程
async def main():
    fetch_data("A")  # 警告：协程未被 awaited！
    # 实际上什么也没执行，必须写：await fetch_data("A")

# 误区 3：在协程中使用同步阻塞代码
import requests
async def bad_fetch(url):
    return requests.get(url)  # 阻塞整个事件循环！改用异步库：aiohttp, aiomysql, asyncpg 等。


# asyncio
asyncio 是 Python 标准库中用于编写并发异步代码的核心模块（Python 3.4+ 引入，3.7+ 成熟）。
它基于事件循环（event loop） 和 协程（coroutine），特别适合 I/O 密集型任务（如网络请求、文件读写、数据库查询）。
异步不是为了加速单个任务，而是为了在等待 I/O 时CPU处理更多任务！

# 入口点：必须在顶层调用
asyncio.run() 会自动创建并管理事件循环，不要嵌套调用。

asyncio.sleep(delay) # 非阻塞地等待指定秒数
asyncio.wait_for(aw, timeout) # 带超时的等待，超时抛出 asyncio.TimeoutError
asyncio.as_completed(aws) # 按完成顺序处理任务（谁先完成谁先处理）
async def main():
    tasks = [fetch_data(i) for i in range(3)]
    for coro in asyncio.as_completed(tasks):
        result = await coro
        print(f"收到结果: {result}")



